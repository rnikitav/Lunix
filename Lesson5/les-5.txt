
    а) Создали файл examples.txt с примерами скаченного с гитхабба
    б) curl -L https://raw.githubusercontent.com/mtuktarov/linux_goodies/master/test_data.txt > examples.txt


1. Написать регулярное выражение, которое проверяет является ли строка валидным IP-адрес. 
   Например, 192.168.1.1 подойдет, а 256.300.1.1 — нет.

       grep -P '^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.|\b)){4}' examples.txt




2. Написать регулярное выражение, которое проверяет, является ли указанный файл картинкой. 
   Картинкой считаем файлы, названия которых оканчиваются на .jpg, .png или .gif.

        grep -P '^([^\/(\.\b)])+(\.[\w]+)?\.(jpg|png|gif)\b' examples.txt 



3. Написать регулярное выражение для проверки, ведет ли ссылка URL на некоторый файл, 
   и это действительно ссылка на картинку. Картинкой считаем файлы, названия которых оканчиваются 
   на .jpg, .png или .gif.


        grep -P '^(https?:\/\/)?(www\.)?[0-9,a-z,A-Z,а-я,_,-]+(\.|:)(([a-z,A-Z,а-я]{2,})|\d{4}).*\/[^\s\/]+\.(gif|jpg|png)\b' examples.txt


        Без локалхост адресов:

        grep -P '^(https?:\/\/)?(www\.)?[0-9,a-z,A-Z,а-я,_,-]+\.[a-z,A-Z,а-я]{2,}.*\/[^\s\/]+\.(gif|jpg|png)\b' examples.txt



4. *Написать регулярное выражение, которое проверяет, является ли строка валидным «белым» IP-адресом (5.255.255.5 подойдет, а 172.16.0.1 — нет).
Будем считать, что белые адреса не принадлежат сетям:
0.0.0.0/8
127.0.0.1/8
169.254.0.0/16
172.16.0.0/12
192.168.0.0/16
10.0.0.0/8
255.255.255.255/32
...172.16.0.0-172.31.255.255

то есть регулярка не должна подходить адресам из этого списка


^(?!0\.|255|169\.2\d|127|10\.|192\.168|172\.1[6-9]|172\.2[0-9]+|172\.3[0-1])(?:^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.|\b)){4})$



5. *Написать регулярное выражение, которое проверяет, что файл в URL 
   (например, https://site.ru/folder/download/test.docx) не является картинкой. 
   Картинкой считаем файлы, названия которых оканчиваются на .jpg, .png или .gif.

        Пример:
        https://site.ru/folder/download/test.docx
        http://site.ru/folder/download/test.js
        http://www.site.ru/folder/download/test.php
        http://www.site.ru/folder/download/test.gif
        http://www.site.ru/folder/download/test.jpg
        http://www.site.ru/folder/download/test.png

 grep -P -n '(?:(https?\:\/\/)?(www\.)?[0-9,a-z,A-Z,а-я,_,-]+\.[a-z,A-Z,а-я]{2,}\/.*\/)[^\s\/]+\.(?!jpg|png|gif).{1,4}\b' examples.txt

        Выведет первые три ссылки



6. У вас есть лог log.txt, который содержит запросы на загрузку файлов. Один запрос на одной строке. 
   IP адрес во втором столбце. Имя файла может быть в любом столбце. Столбцы разделены одним или 
   несколькими пробелами. Нужно написать выражение в одну строку, которое выведет список всех IP 
   адресов за исключением loopback интерфейсов, с которых запрашивался файл /closeio.html, а 
   также количество таких запросов для каждого адреса. Результат должен быть отсортирован по этому 
   значению. Можно использовать стандартные тулы, которые запустятся на большинстве UNIX системах.


    К тому же, для IP тоже используется технология loopback интерфейса. Самый распространенный IP на 
    основе loopback — 127.0.0.1. В IPv4 — 127.0.0.0 до 127.255.255.255. IPv6 же принимает только 
    0:0:0:0:0:0:0:1.


https://regex101.com/r/mI8Oe3/3

(\/closeio.html\s+(?!127)(?:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.|\b)){4})|((?!127)((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.|\b)){4}\s+\w+?\s+?\w+?\s+?\w+?\s+?\w+?\s\/closeio.html$)


Больше не успел сделать











7. нужно в строке найти номер телефона, который может иметь вид
   81234567890 +71234567890 1234567890 8-123-456-78-90 123-456-78-90 
   +7-123-456-78-90 123-456-78-90 +7(123)456-78-90 8(123)456-78-90 
   (123)456-78-90 8(123)456-7890 +7(123)456-7890 (123)456-7890 
   8 123 456 78 90 123 456 78 90 +7 123 456 78 90 123 456 78 90 
   +7(123)456 78 90 8(123)456 78 90 (123)456 78 90 8(123)456 7890 
   +7(123)456 7890 (123)456 7890 и заменить на один тип +7(123)4561234. 
   Остальную часть строки, которая телефоном не является оставить без изменений. 
   Написать набор тестовых данных для проверки

Решение только для первого телефона, дальше идет и имя и потом телефон в том же формате без зменений

sed -En 's/^([a-z,а-я]+)\d?\s?\+?[7-8]?\(?\-?\s?([0-9]{3})\)?\-?\s?([0-9]{3})\-?\s?([0-9]{2})\-?\s?([0-9]{2})\s(.*)/name:  \1  teelephone:  +7(\2)\3\4\5    \6/p' exampleTelep.txt


Решение уже с заменой и второго телефона в строке. Приведение его к одному типу 


sed -En 's/^([a-z,а-я]+)\d?\s?\+?[7-8]?\(?\-?\s?([0-9]{3})\)?\-?\s?([0-9]{3})\-?\s?([0-9]{2})\-?\s?([0-9]{2})\s+([a-z]+)\s+?\+?[7-8]{1}?\(?\s?([0-9]{3}?)\)?\s?([0-9]{3}?)\s?(.*)?/name:  \1  teelephone:  +7(\2)\3\4\5    \6    +7(\7)\8\9/p' exampleTelep.txt



В JavaScrit такая бы задача примерно решалась 
console.log('+7-(000) 000:00-00'.match(/\d/g).join('')); // => 70000000000
добавив небольшой цикл с проверкой индекса элемента чтобы подставить ()








